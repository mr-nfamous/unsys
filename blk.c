
/*°′″  «»  ≤≥  ≠≈  —¦  ÷×  !¡  ©®  £€  $¢  №⋕  λμ  πφ  ∑∏  ¶§  †‡  ±∞  √∆  ∫∳ */

/*
ascii           : Basic_Latin                       0000..007f N=128
latin_1         : Latin_1_Sup                       0080..00ff N=128
latin_a         : Latin_Ext_A                       0100..017F N=128
latin_b         : Latin_Ext_B                       0180..024F N=208
ipa_ext         : IPA_Ext                           0250..02AF N=96
mod_let         : Spacing_Modifier_Letters          02B0..02FF N=80
mark            : Combining_Diacritical_Marks       0300..036F N=112
greek           : Greek_And_Coptic                  0370..03FF N=144
cyrillic        : Cyrillic                          0400..04FF N=256
cyrillic_sup    : Cyrillic_Sup                      0500..052F N=48
armenian        : Armenian                          0530..058F N=96
hebrew          : Hebrew                            0590..05FF N=112
arabic          : Arabic                            0600..06FF N=256
syriac          : Syriac                            0700..074F N=80
arabic_sup      : Arabic_Sup                        0750..077F N=48
thaana          : Thaana                            0780..07BF
nko             : NKo                               07C0..07FF
samaritan       : Samaritan                         0800..083F
mandaic         : Mandaic                           0840..085F
syriac_sup      : Syriac_Sup                        0860..086F
arabic_ext_b    : Arabic_Ext_B                      0870..089F
arabic_ext_a    : Arabic_Ext_A                      08A0..08FF
devanagari      : Devanagari                        0900..097F
bengali         : Bengali                           0980..09FF
gurmukhi        : Gurmukhi                          0A00..0A7F
gujarati        : Gujarati                          0A80..0AFF
oriya           : Oryia                             0B00..0B7F
tamil           : Tamil                             0B80..0BFF
telugu          : Telugu                            0C00..0C7F
kannada         : Kannada                           0C80..0CFF
malayalam       : Malayalam                         0D00..0D7F
sinhala         : Sinhala                           0D80..0DFF
thai            : Thai                              0E00..0E7F
lao             : Lao                               0E80..0EFF
tibetan         : Tibetan                           0F00..0FFF
myanmar         : Myanmar                           1000..109F
georgian        : Georgian                          10A0..10FF
jamo            : Hangul_Jamo                       1100..11FF
ethiopic        : Ethiopic                          1200..137F
ethiopic_sup    : Ethiopic_Sup                      1380..139F
cherokee        : Cherokee                          13A0..13FF
ucas            : Canadian_Syllabics                1400..167F
ogham           : Ogham                             1680..169F
runic           : Runic                             16A0..16FF
tagalog         : Tagalog                           1700..171F
buhid           : Buhid                             1740..175F
hanunoo         : Hanunoo                           1720..173F
tagbanwa        : Tagbanwa                          1760..177F
khmer           : Khmer                             1780..17FF
mongolian       : Mongolian                         1800..18AF
ucas_ext        : Canadian_Syllabics_Ext            18B0..18FF
limbu           : Limbu                             1900..194F
tai_Le          : Tai_Le                            1950..197F
new_tai_lue     : New_Tai_Lue                       1980..19DF
khmer_sym       : Khmer_Symbols                     19E0..19FF
buginese        : Buginese                          1A00..1A1F
tai_tham        : Tai_Tham                          1A20..1AAF
diacritical_ext : Diacritical_Marks_Ext             1AB0..1AFF
balinese        : Balinese                          1B00..1B7F
sundanese       : Sundanese                         1B80..1BBF
batak           : Batak                             1BC0..1BFF
lepcha          : Lepcha                            1C00..1C4F
ol_chiki        : Ol_Chiki                          1C50..1C7F
cyrillic_ext_c  : Cyrillic_Ext_C                    1C80..1C8F
georgian_ext    : Georgian_Ext                      1C90..1CBF
sundanese_sup   : Sundanese_Sup                     1CC0..1CCF
vedic_ext       : Vedic_Ext                         1CD0..1CFF
phonetic_ext    : Phonetic_Ext                      1D00..1D7F
phonetic_ext_sup: Phonetic_Ext_Sup                  1D00..1D7F
marks_sup       : Diacritical_Marks_Sup             1DC0..1DFF
latin_ext       : Latin_Ext_Additional              1E00..1EFF
greek_ext       : Greek_Ext                         1F00..1FFF
punct           : General_Punctuation               2000..206F
super_sub       : Superscripts_And_Subscripts       2070..209F
currency        : Currency_Symbols                  20A0..20CF
sym_mark        : Diacritical_Marks_For_Symbols     20D0..20FF
letterlike      : Letterlike_Symbols                2100..214F
num_forms       : Number_Forms                      2150..218F
arrow           : Arrows                            2190..21FF
math_op         : Math_Operators                    2200..22FF
misc_tech       : Misc_Technical                    2300..23FF
cntrl_pic       : Control_Pictures                  2400..243F
ocr             : Optical_Character_Recognition     2440..245F
enclosed_alnum  : Enclosed_Alphanumerics            2460..24FF
box_drawing     : Box_Drawing                       2500..257F
block_element   : Block_Elements                    2580..259F
geometric_shape : Geometric_Shapes                  25A0..25FF
misc_sym        : Misc_Symbols                      2600..26FF
dingbat         : Dingbats                          2700..27BF
misc_math_a     : Misc_Math_Symbols_A               27C0..27EF
sup_arrow_a     : Sup_Arrows_A                      27F0..27FF
braille         : Braille_Patterns                  2800..28FF
sup_arrow_b     : Sup_Arrows_B                      2900..297F
misc_math_b     : Misc_Math_Symbols_B               2980..29FF
sup_math_op     : Sup_Math_Operators                2A00..2AFF
misc_arrow      : Misc_Symbols_And_Arrows           2B00..2BFF
glagolitic      : Glagolitic                        2C00..2C5F
latin_c         : Latin_Ext_C                       2C60..2C7F
coptic          : Coptic                            2C80..2CFF
georgian_sup    : Georgian_Sup                      2D00..2D2F
tifinagh        : Tifinagh                          2D30..2D7F
ethiopic_ext    : Ethiopic_Ext                      2D80..2DDF
cyrillic_ext_a  : Cyrillic_Ext_A                    2DE0..2DFF
sup_punct       : Sup_Punctuation                   2E00..2E7F
cjk_radical_sup : CJK_Radicals_Sup                  2E80..2EFF
kangxi          : Kangxi_Radicals                   2F00..2FDF
idc             : Ideographic_Description_Chars     2FF0..2FFF
cjk_symbol      : CJK_Symbols_And_Punct             3000..303F
hiragana        : Hiragana                          3040..309F
katakana        : Katakana                          30A0..30FF
bopomofo        : Bopomofo                          3100..312F
compat_jamo     : Hangul_Compatibility_Jamo         3130..318F
kanbun          : Kanbun                            3190..319F
bopomofo_ext    : Bopomofo_Ext                      31A0..31BF
cjk_stroke      : CJK_Strokes                       31C0..31EF
katakana_ext    : Katakana_Phonetic_Ext             31F0..31FF
enclosed_cjk    : Enclosed_CJK_Letters_And_Months   3200..32FF
cjk_compat      : CJK_Compatibility                 3300..33FF
cjk_ext_a       : CJK_Unified_Ideographs_A          3400..4DBF
yijing          : Yijing_Hexagram_Symbols           4DC0..4DFF
cjk             : CJK_Unified_Ideographs            4E00..9FFF
yi_radical      : Yi_Radicals                       A000..A48F
yi_syl          : Yi_Syllables                      A490..A4CF
lisu            : Lisu                              A4D0..A4FF
vai             : Vai                               A500..A63F
cyrillic_ext_b  : Cyrillic_Ext_B                    A640..A69F
bamum           : Bamum                             A6A0..A6FF   
mod_tone        : Modifier_Tone_Letters             A700..A71F
latin_d         : Latin_Ext_D                       A720..A7FF
syloti_nagri    : Syloti_Nagri                      A800..A82F
indic_num_form  : Indic_Number_Forms                A830..A83F
phags_pa        : Phags_Pa                          A840..A87F
saurashtra      : Saurashtra                        A880..A8DF
devanagari_ext  : Devanagari_Ext                    A8E0..A8FF
kayah_li        : Kayah_Li                          A900..A92F
rejang          : Rejang                            A930..A95F
jamo_a          : Hangul_Jamo_Ext_A                 A960..A97F
avanese         : Javanese                          A980..A9DF
myanmar_b       : Myanmar_Ext_B                     A9E0..A9FF
cham            : Cham                              AA00..AA5F
myanmar_a       : Myanmar_Ext_A                     AA60..AA7F
tai_viet        : Tai_Viet                          AA80..AADF
meetei_mayek_ext: Meetei_Mayek_Ext                  AAE0..AAFF
ethiopic_a      : Ethiopic_Ext_A                    AB00..AB2F
latin_e         : Latin_Ext_E                       AB30..AB6F
cherokee_sup    : Cherokee_Sup                      AB70..ABBF
meetei_mayek    : Meetei_Mayek                      ABC0..ABFF
hangul          : Hangul_Syllables                  AC00..D7AF
jamo_b          : Hangul_Jamo_Ext_B                 D7B0..D7FF
hi_surrogate    : High_Surrogates                   D800..DB7F
hi_pu_surrogate : High_Private_Use_Surrogates       DB80..DBFF
lo_surrogate    : Low_Surrogates                    DC00..DFFF
pua             : Private_Use_Area                  E000..F8FF
cjk_compat_ig   : CJK_Compatibility_Ideographs      F900..FAFF
alpha_pf        : Alphabetic_Presentation_Forms     FB00..FB4F
arabic_pf_a     : Arabic_Presentation_Forms_A       FB50..FDFF
vs              : Variation_Selectors               FE00..FE0F
vert_form       : Vertical_Forms                    FE10..FE1F
half_mark       : Combining_Half_Marks              FE20..FE2F
cjk_compat_form : CJK_Compatibility_Forms           FE30..FE4F
small_form      : Small_Form_Variants               FE50..FE6F
arabic_pf_b     : Arabic_Presentation_Forms_B       FE70..FEFF
hwfwf           : Halfwidth_And_Fullwidth_Forms     FF00..FFEF
special         : Specials                          FFF0..FFFF
linear_b_sl     : Linear_B_Syllabary                10000..1007F
linear_b_ig     : Linear_B_Ideograms                10080..100FF
aegean_num      : Aegean_Numbers                    10100..1013F
greek_num       : Ancient_Greek_Numbers             10140..1018F
ancient_sym     : Ancient_Symbols                   10190..101CF
phaistos        : Phaistos_Disc                     101D0..101FF
nb              : No_Block                          10200..1027F
lycian          : Lycian                            10280..1029F
carian          : Carian                            102A0..102DF
coptic_epact_num: Coptic_Epact_Numbers              102E0..102FF
old_italic      : Old_Italic                        10300..1032F
gothic          : Gothic                            10330..1034F
old_permic      : Old_Permic                        10350..1037F
ugaritic        : Ugaritic                          10380..1039F
old_persian     : Old_Persian                       103A0..103DF

nb              : No_Block                          103E0..103FF

deseret         : Deseret                           10400..1044F
shavian         : Shavian                           10450..1047F
osmanya         : Osmanya                           10480..104AF
osage           : Osage                             104B0..104FF
elbasan         : Elbasan                           10500..1052F
aghb            : Caucasian_Albanian                10530..1056F
vithkuqi        : Vithkuqi                          10570..105BF
linear_a        : Linear_A                          10600..1077F
latin_f         : Latin_Ext_F                       10780..107BF
cypriot_sl      : Cypriot_Syllabary                 10800..1083F
imperial_aramaic: Imperial_Aramaic                  10840..1085F
palmyrene       : Palmyrene                         10860..1087F
nabataean       : Nabataean                         10880..108AF

nb              : No_Block                          108B0..108DF N=48

hatran          : Hatran                            108E0..108FF
phoenician      : Phoenician                        10900..1091F
lydian          : Lydian                            10920..1093F
meroitic_hgl    : Meroitic_Hieroglyphs              10980..1099F
meroitic_cursive: Meroitic_Cursive                  109A0..109FF
kharoshthi      : Kharoshthi                        10A00..10A5F
old_arabian_s   : Old_South_Arabian                 10A60..10A7F
old_arabian_n   : Old_North_Arabian                 10A80..10A9F

nb              : No_Block                          10AA0..10ABF N=32

manichaean      : Manichaean                        10AC0..10AFF
avestan         : Avestan                           10B00..10B3F
inscr_parthian  : Inscriptional_Parthian            10B40..10B5F
inscr_pahlavi   : Inscriptional_Pahlavi             10B60..10B7F
psalter_pahlavi : Psalter_Pahlavi                   10B80..10BAF
old_turkic      : Old_Turkic                        10C00..10C4F
old_hungarian   : Old_Hungarian                     10C80..10CFF
hanifi_rohingya : Hanifi_Rohingya                   10D00..10D3F
rumi            : Rumi_Numeral_Symbols              10E60..10E7F
yezidi          : Yezidi                            10E80..10EBF
old_sogdian     : Old_Sogdian                       10F00..10F2F
sogdian         : Sogdian                           10F30..10F6F
chorasmian      : Chorasmian                        10FB0..10FDF
elymaic         : Elymaic                           10FE0..10FFF
brahmi          : Brahmi                            11000..1107F
kaithi          : Kaithi                            11080..110CF
sora_sompeng    : Sora_Sompeng                      110D0..110FF
chakma          : Chakma                            11100..1114F
mahajani        : Mahajani                          11150..1117F
sharada         : Sharada                           11180..111DF
sinhala_arch_num: Sinhala_Archaic_Numbers           111E0..111FF
khojki          : Khojki                            11200..1124F
multani         : Multani                           11280..112AF
khudawadi       : Khudawadi                         112B0..112FF
grantha         : Grantha                           11300..1137F
newa            : Newa                              11400..1147F
tirhuta         : Tirhuta                           11480..114DF
siddham         : Siddham                           11580..115FF
modi            : Modi                              11600..1165F
mongolian_sup   : Mongolian_Sup                     11660..1167F
akri            : Takri                             11680..116CF
ahom            : Ahom                              11700..1174F
dogra           : Dogra                             11800..1184F
warang_citi     : Warang_Citi                       118A0..118FF
dives_akuru     : Dives_Akuru                       11900..1195F
mandinagari     : Nandinagari                       119A0..119FF
zanabazar_square: Zanabazar_Square                  11A00..11A4F
soyombo         : Soyombo                           11A50..11AAF
ucas_a          : Canadian_Syllabics_Ext_A          11AB0..11ABF
pau_cin_hau     : Pau_Cin_Hau                       11AC0..11AFF
bhaiksuki       : Bhaiksuki                         11C00..11C6F
marchen         : Marchen                           11C70..11CBF
masaram_gondi   : Masaram_Gondi                     11D00..11D5F
gunjala_gondi   : Gunjala_Gondi                     11D60..11DAF
makasar         : Makasar                           11EE0..11EFF
lisu_sup        : Lisu_Sup                          11FB0..11FBF
tamil_Sup       : Tamil_Sup                         11FC0..11FFF
cuneiform       : Cuneiform                         12000..123FF
cuneiform_punct : Cuneiform_Numbers_And_Punct       12400..1247F
early_cuneiform : Early_Dynastic_Cuneiform          12480..1254F
cypro_minoan    : Cypro_Minoan                      12F90..12FFF
egyptian_hgl    : Egyptian_Hieroglyphs              13000..1342F
egyptian_hgl_fmt: Egyptian_Hieroglyph_Format        13430..1343F
anatolian_hgl   : Anatolian_Hieroglyphs             14400..1467F
bamum_sup       : Bamum_Sup                         16800..16A3F
mro             : Mro                               16A40..16A6F
tangsa          : Tangsa                            16A70..16ACF
bassa_vah       : Bassa_Vah                         16AD0..16AFF
pahawh_hmong    : Pahawh_Hmong                      16B00..16B8F
medefaidrin     : Medefaidrin                       16E40..16E9F
miao            : Miao                              16F00..16F9F
ig_sym_punct    : Ideograph_Symbols_And_Punct       16FE0..16FFF
tangut          : Tangut                            17000..187FF                             
tangut_component: Tangut_Components                 18800..18AFF
khitan_small    : Khitan_Small_Script               18B00..18CFF
tangut_sup      : Tangut_Sup                        18D00..18D7F
kana_b          : Kana_Ext_B                        1AFF0..1AFFF
kana_sup        : Kana_Sup                          1B000..1B0FF
kana_a          : Kana_Ext_A                        1B100..1B12F
small_kana_ext  : Small_Kana_Ext                    1B130..1B16F
nushu           : Nushu                             1B170..1B2FF
duployan        : Duployan                          1BC00..1BC9F
shorthand_fmt   : Shorthand_Format_Controls         1BCA0..1BCAF
znamenny_music  : Znamenny_Musical_Notation         1CF00..1CFCF
byzantine_nusic : Byzantine_Musical_Symbols         1D000..1D0FF
music           : Musical_Symbols                   1D100..1D1FF
greek_nusic     : Ancient_Greek_Musical_Notation    1D200..1D24F
mayan_numeral   : Mayan_Numerals                    1D2E0..1D2FF
tai_xuan_jing   : Tai_Xuan_Jing_Symbols             1D300..1D35F
counting_rod    : Counting_Rod_Numerals             1D360..1D37F
math_alnum      : Math_Alphanumeric_Symbols         1D400..1D7FF
sutton_sign     : Sutton_SignWriting                1D800..1DAAF
latin_g         : Latin_Ext_G                       1DF00..1DFFF
glagolitic_sup  : Glagolitic_Sup                    1E000..1E02F
hmnp            : Nyiakeng_Puachue_Hmong            1E100..1E14F
toto            : Toto                              1E290..1E2BF
wancho          : Wancho                            1E2C0..1E2FF
ethiopic_b      : Ethiopic_Ext_B                    1E7E0..1E7FF
mende_kikakui   : Mende_Kikakui                     1E800..1E8DF
adlam           : Adlam                             1E900..1E95F
indic_num       : Indic_Siyaq_Numbers               1EC70..1ECBF
ottoman_num     : Ottoman_Siyaq_Numbers             1ED00..1ED4F
arabic_math     : Arabic_Math_Symbols               1EE00..1EEFF
mahjong         : Mahjong_Tiles                     1F000..1F02F
domino          : Domino_Tiles                      1F030..1F09F
playing_card    : Playing_Cards                     1F0A0..1F0FF
encl_alnum_sup  : Enclosed_Alphanumeric_Sup         1F100..1F1FF
encl_ig_sup     : Enclosed_Ideographic_Sup          1F200..1F2FF
misc_sym_pg     : Misc_Symbols_And_Pictographs      1F300..1F5FF
emoticons       : Emoticons                         1F600..1F64F
orn_dingbat     : Ornamental_Dingbats               1F650..1F67F
map_sym         : Transport_And_Map_Symbols         1F680..1F6FF
alchemy         : Alchemical_Symbols                1F700..1F77F
geometric_ext   : Geometric_Shapes_Ext              1F780..1F7FF
sup_arrow_c     : Sup_Arrows_C                      1F800..1F8FF
sym_pg_sup      : Sup_Symbols_And_Pictographs       1F900..1F9FF
chess           : Chess_Symbols                     1FA00..1FA6F
sym_pg_a        : Symbols_And_Pictographs_Ext_A     1FA70..1FAFF
sym_legacy      : Symbols_For_Legacy_Computing      1FB00..1FBFF
cjk_b           : CJK_Unified_Ideograph_Ext_B       20000..2A6DF
cjk_c           : CJK_Unified_Ideograph_Ext_C       2A700..2B73F
cjk_d           : CJK_Unified_Ideograph_Ext_D       2B740..2B81F
cjk_e           : CJK_Unified_Ideograph_Ext_E       2B820..2CEAF
cjk_f           : CJK_Unified_Ideograph_Ext_F       2CEB0..2EBEF
cjk_compat_sup  : CJK_Compat_Ideograph_Sup          2F800..2FA1F
cjk_g           : CJK_Unified_Ideograph_Ext_G       30000..3134F
tags            : Tags                              E0000..E007F
vs_sup          : Variation_Selectors_Sup           E0100..E01EF
sup_pua_a       : Sup_Private_Use_Area_A            F0000..FFFFF
sup_pua_b       : Sup_Private_Use_Area_B            100000..10FFFF
nb              : No_Block
                : 0123456789abcdef:123456789abcdef
{
    {0,},
    {1,
}
*/

#include <pthread.h>
#include <fcntl.h>

#include "unstddef.h"
#include "untimely.h"
#include "unarray.h"

#include "undict.h"


Dict *  Dict_new    (hash_t);

void    Dict_destroy(Dict *);

void *  Dict_get    (Dict *, const char *);

hash_t  Dict_put    (Dict *, const char *, void *);

void *  Dict_hget   (Dict *, const char *, hash_t);

hash_t  Dict_hput   (Dict *, const char *, void *, hash_t);

hash_t  unstrhash(const char *);
hash_t  uncasehash(const char *);

ptrdiff_t unstrrepr(const char *, FILE *);

static inline bool
Unicode_IS(char32_t c) {
    return (0 <= c) && (c <= 0x10FFFF);
}

static inline bool
Unicode_NOPE(char32_t c) {
    return !Unicode_IS(c);
}

static uint8_t NBIT[256] = {
    0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
};

typedef struct {
    unsigned lo: 21, :0, hi: 21, iv: 1, :0;
}   UnicodeRange;

UnicodeRange *
UnicodeRange_init(UnicodeRange *range, char32_t lo, char32_t hi, _Bool iv) {
    if (Unicode_NOPE(lo) || Unicode_NOPE(hi)) {
        return NULL;
    }
    *range = (lo > hi)
        ?   (UnicodeRange){.lo=hi, .hi=lo, .iv=iv}
        :   (UnicodeRange){.lo=lo, .hi=hi, .iv=iv};
    return range;
}

_Bool
UnicodeRange_contains(UnicodeRange range, char32_t chr) {
    return ((range.lo > chr) && range.iv) || ((range.hi < chr) && range.iv);
}



static const unsigned char
UNCASE_HASH[256] = {
    /*
    The uncased hash function transforms [A..Z] 
    and [a..z] to 128+(c.upper()-'A') before hashing.
    Thus, coincidentally, hashing strings that do not 
    contain any letters will produce the same result,
    while strings that*do* contain letters *never* 
    produce the same result.
    */
    0000,0001,0002,0003,0004,0005,0006,0007,
    0010,0011,0012,0013,0014,0015,0016,0017,
    0020,0021,0022,0023,0024,0025,0026,0027,
    0030,0031,0032,0033,0034,0035,0036,0037,
    0040,0041,0042,0043,0044,0045,0046,0047,
    0050,0051,0052,0053,0054,0055,0056,0057,
    0060,0061,0062,0063,0064,0065,0066,0067,
    0070,0071,0072,0073,0074,0075,0076,0077,
    0100,0200,0201,0202,0203,0204,0205,0206,
    0207,0210,0211,0212,0213,0214,0215,0216,
    0217,0220,0221,0222,0223,0224,0225,0226,
    0227,0230,0231,0133,0134,0135,0136,0137,
    0140,0200,0201,0202,0203,0204,0205,0206,
    0207,0210,0211,0212,0213,0214,0215,0216,
    0217,0220,0221,0222,0223,0224,0225,0226,
    0227,0230,0231,0173,0174,0175,0176,0177,
    0101,0102,0103,0104,0105,0106,0107,0110,
    0111,0112,0113,0114,0115,0116,0117,0120,
    0121,0122,0123,0124,0125,0126,0127,0130,
    0131,0132,0232,0233,0234,0235,0236,0237,
    0240,0241,0242,0243,0244,0245,0246,0247,
    0250,0251,0252,0253,0254,0255,0256,0257,
    0260,0261,0262,0263,0264,0265,0266,0267,
    0270,0271,0272,0273,0274,0275,0276,0277,
    0300,0301,0302,0303,0304,0305,0306,0307,
    0310,0311,0312,0313,0314,0315,0316,0317,
    0320,0321,0322,0323,0324,0325,0326,0327,
    0330,0331,0332,0333,0334,0335,0336,0337,
    0340,0341,0342,0343,0344,0345,0346,0347,
    0350,0351,0352,0353,0354,0355,0356,0357,
    0360,0361,0362,0363,0364,0365,0366,0367,
    0370,0371,0372,0373,0374,0375,0376,0377,
};

static inline uint8_t
hashbits(hash_t i) {
    if (i <  0x00000004) return 003;
    if (i <= 0x000000FF) return 001+NBIT[i];
    if (i <= 0x0000FFFF) return 011+NBIT[i>>010];
    if (i <= 0x00FFFFFF) return 021+NBIT[i>>020];
    else                 return 031+NBIT[i>>030];
}

static inline _Bool
Dict_FULL(Dict *d) {
    return d->used >= d->size;
}

ptrdiff_t
unstrrepr(const char *src, FILE *dst) {
    if (dst == NULL) {
        dst = stdout;
    }
    ptrdiff_t len = 1;
    int n = len-len;
    if (fputc('"', dst) < 0) {
        return -1;
    }
    while (*src) {
        return 0;
    }
    return n;
}

hash_t
unstrhash(const char *str) {
    size_t i = 0;
    union {
        uint64_t v;
        struct {
            uint16_t a;
            uint32_t b;
        };
    } hash = {.a=1, .b=0};
    for (; str[i]; i++) {
        hash.a += str[i];
        hash.b += hash.a;
    }
    if (!hash.v) {
        return 0;
    }
    hash.v ^= hash.v>>12;
    hash.v ^= hash.v<<25;
    hash.v ^= hash.v>>27;
    return    hash.v>>33;
}

hash_t
uncasehash(const char *str) {
    size_t i = 0;
    union {
        uint64_t v;
        struct {
            uint16_t a;
            uint32_t b;
        };
    } hash = {.a=1, .b=0};
    for (; str[i]; i++) {
        const uint16_t x = str[i];
        hash.a += UNCASE_HASH[x];
        hash.b += hash.a;
    }
    if (!hash.v) {
        return 0;
    }
    hash.v ^= hash.v>>12;
    hash.v ^= hash.v<<25;
    hash.v ^= hash.v>>27;
    return    hash.v>>33;
}

Dict *
Dict_new(hash_t nkey) {
    Dict dict = {
        .nkey=nkey, 
        .lsh=hashbits(nkey),
        .kcmp=strcmp,
        .hash=unstrhash,
    };
    dict.rsh            = 31-dict.lsh;
    dict.size           = 1<<dict.lsh;
    const size_t ptrs   = sizeof(DictItem*)*dict.size;
    const size_t data   = sizeof(DictItem)*nkey;
    const size_t xtra   = data+ptrs;
    const size_t need   = sizeof(Dict)+xtra;
    ptrview_t buf       = {malloc(need)};
    Dict *self          = buf.addr;
    if (!self) {
        return NULL;
    }

#   if CHASTE_DICTS
    if (pthread_rwlock_init(&self->lock, NULL)) {
        free(self);
        return NULL;
    }
#   endif

    if (memcpy(self, &dict, sizeof *self) == NULL) {
        fail: {
            Dict_destroy(self);
            return NULL;
        }
    }
    if (memset(buf.addr=self+1, 0, xtra) == NULL) {
        goto fail;
    }
    self->map   = buf.addr;
    self->data  = (void *)(buf.c+ptrs);
    return self;
}

void 
Dict_destroy(Dict *d) {
#   if CHASTE_DICTS
    (void) pthread_rwlock_destroy(&d->lock);
#   endif /* CHASTE_DICTS */
    (void) memset(d, 0, sizeof *d);
    free(d);
}

void *
Dict_hget(Dict *d, const char *k, hash_t hash) {
    assert(errno == 0);
    assert(hash <= HASH_MAX);

#   if CHASTE_DICTS
    if (pthread_rwlock_rdlock(&d->lock)) {
        switch (errno) {
            case EDEADLK:   return NULL;
            case EAGAIN:    return NULL;
            default:        abort();
        }
    }
#   endif /* CHASTE_DICTS */

    for (DictItem *i=d->map[hash>>d->rsh]; i; i=i->next) {
        if (d->kcmp(i->key, k) == 0) {
#           if CHASTE_DICTS
            if (pthread_rwlock_unlock(&d->lock)) {
                return NULL;
            }
#           endif /* CHASTE_DICTS */
            return i->val;
        }
    }
#   if CHASTE_DICTS
    if (pthread_rwlock_unlock(&d->lock)) {
        return NULL;
    }
#   endif /* CHASTE_DICTS */

    return NULL;
}

hash_t
Dict_hput(Dict *d, const char *k , void *v, hash_t hash) {
#   if CHASTE_DICTS
    if (pthread_rwlock_wrlock(&d->lock)) {
        return DICT_OP_FAILURE;
    }
#   endif
    const hash_t slot = hash>>d->rsh;
    DictItem *i = d->map[slot];
    DictItem **b;
    if (i) {
        the_next_iteration: {
            if ((i->key == k) || !d->kcmp(k, i->key)) {
                goto a_successful_insertion;
            }
            if (i->next) {
                i = i->next;
                goto the_next_iteration;
            }
        }
        b = &i->next;
    }
    else {
        b = d->map+slot;
    }
    if (Dict_FULL(d)) {
        hash = DICT_OP_FAILURE;
    }
    else {
        i = d->used+++d->data;
        i->next=NULL, i->key=k, *b=i;
        a_successful_insertion: {
            i->val = v;
        }
    }
#   if CHASTE_DICTS
    if (pthread_rwlock_unlock(&d->lock)) {
        return DICT_OP_FAILURE;
    }
#   endif
    return hash;
}

void *
Dict_get(Dict *d, const char *k) {
    return Dict_hget(d, k, d->hash(k));
}

hash_t
Dict_put(Dict *d, const char *k, void *v) {
    return Dict_hput(d, k, v, d->hash(k));
}

static 
struct UCD_block UCD_BLOCK[500];

int
scanz(void) {
    size_t size;
    char *line = NULL;
    FILE *src = fopen("/sdcard/Python/unsys/blocks.txt", "r");
    if (!src) {
        return 0-1;
    }
  
    struct UCD_block *b = UCD_BLOCK;
    for (int i=0; 0 < getline(&line, &size, src); i++) {
        if (sscanf(line, "%x..%x%s:%s", &b->lo, &b->hi, b->id, b->na) < 0) {
            (void) fclose(src);
            (void) free(line);
            return 0-1;
        }
        free(line), line=NULL;
        if (i >= 0) {
            break;
        }
        b++;
    }
    printf("%05x..%05x %.16s:%32s\n", b->lo, b->hi, b->id, b->na);
    return fclose(src);
}

Array *
Array_new(enum typecode type, size_t size) {
    const size_t item = Struct_SIZE[type];
    if (item == 0) {
        errno = EINVAL;
        return  NULL;
    }
    if (size < 2) {
        size = 2;
    }
    Array *array = malloc(sizeof(Array));
    if (array == NULL) {
        return   NULL;
    }
    void *data = malloc(size*item);
    if (data == NULL) {
        return free(array), NULL;
    }
    if (pthread_rwlock_init(Array_GET_LOCK(array), 0)) {
        return free(array), free(data), NULL;
    }
    Array_SET_TYPE(array, type);
    Array_SET_DATA(array, data);
    Array_SET_SIZE(array, size);
    Array_SET_USED(array, 0);
    return array;
}

void
Array_destroy(Array *array) {
    (void) pthread_rwlock_destroy(Array_GET_LOCK(array));
    (void) memset(Array_GET_DATA(array), 0, Array_GET_NBYTES(array));
    free(Array_GET_DATA(array));
    free(array);
}

Array *
Array_append(Array *array, const void *value) {
    if (Array_WRLOCK(array)) {
        return NULL;
    }
    array = Array_APPEND(array, value);
    return  Array_WRUNLOCK(array) ? NULL : array;
}

Array *
Array_insert(Array *array, size_t index, const void *value) {
    if (Array_WRLOCK(array)) {
        return NULL;
    }
    array = Array_INSERT(array, index, value);
    return  Array_WRUNLOCK(array) ? NULL : array;
}

void *
Array_getitem(Array *array, ptrdiff_t index, void *v) {
    if (Array_RDLOCK(array)) {
        return NULL;
    }
    void *addr = Array_GET(array, index);
    if (addr != NULL) {
        if (memmove(v, addr, Array_GET_ITEMSIZE(array)) == NULL) {
            v = NULL;
        }
    }
    if (Array_RDUNLOCK(array)) {
        return NULL;
    }
    return v;
}

Array *
Array_setitem(Array *array, ptrdiff_t index, const void *value) {
    if (Array_WRLOCK(array)) {
        return NULL;
    }
    Array *a = Array_SET(array, index, value);
    if (Array_WRUNLOCK(array)) {
        return NULL;
    }
    return a;
}

Array *
Array_delitem(Array *array, ptrdiff_t index, void *v) {
    if (Array_WRLOCK(array)) {
        printf("Array_wrlock failed\n");
        return NULL;
    }
    Array *a = Array_DEL(array, index, v);
    if (Array_WRUNLOCK(array)) {
        printf("Array_wrunlock failed\n");
        return NULL;
    }
    if (a == NULL) {
        printf("Array_DEL failed?\n");
    }
    return a;
}


/*
void *
Array_getitem(void *restrict v, Array *restrict array, ptrdiff_t index) {
    if (Array_RDLOCK(a)) {
        return NULL;
    }
    if (Array_CHECK_INDEX(a, &i) < 0) {
        goto the_end;
    }
    const ptrdiff_t z = (ptrdiff_t) Array_GET_ITEMSIZE(a);
    printf(
        "&((a->addr=%p)[(i=%td)*(z=%td)])=%p\n",
        a->addr,
        i, z,
        &a->addr[i*z]);
    if (memcpy(v, i*z+a->addr, z) == NULL) {
        v = NULL;
    }
    the_end: {
        return Array_UNLOCK(a) ? NULL : v;
    }
}
*/


/*
typedef struct {
    char32_t lo;
    char32_t hi;
}   chrrange_t;

typedef struct {
    size_t      len;
    size_t      end;
    chrrange_t *seq;
    unsigned   
        mseq:   1,
        mset:   1,
        :       0;
}   chrset_t;

chrset_t *
chrset_new(size_t len) {
    chrset_t *set;
    if (len < 8) {
        len = 8;
    }
    set = malloc(sizeof *set);
    if (set == NULL) {
        return NULL;
    }
    set->len = len;
    set->end = 0U;
    set->seq = malloc(len*sizeof *set->seq);
    if (set->seq == NULL) {
        free(set);
        return NULL;
    }
    set->mseq = true;
    set->mset = true;
    return set;
}

void
chrset_destroy(chrset_t *set) {
    if (set->mseq) {
        set->mseq = false;
        free(set->seq);
    }
    if (set->mset) {
        set->mset = false;
        free(set);
    }
}

static inline int
unchr_RANGE_DIST(char32_t c, chrrange_t range) {
    if (c < range.lo) {
        return 0-((int) (range.lo-c));
    }
    if (c > range.hi) {
        return (int) (c-range.hi);
    }
    return 0;
}

static inline bool
unchr_IN_RANGE(char32_t c, chrrange_t range) {
    if (c < range.lo) {
        return false;
    }
    if (c > range.hi) {
        return false;
    }
    return true;
}

static inline bool
unchr_IN_SET(char32_t c, const chrset_t *restrict set) {
    for (size_t a=0, z=set->end; a < z; ) {
        const size_t i = (a+z)>>1;
        const chrrange_t range = set->seq[i];
        if (c > range.hi) {
            z = i;
            continue;
        }
        if (c < range.lo) {
            a = i+1;
            continue;
        }
        return true;
    }
    return false;
}

*/

/*
typedef struct {
    size_t  narg;
    ptr_t  *args;
}   argspec_t;

typedef struct {
    const char *fmt;
    signed char ali;
}   Struct;

Struct *
Struct_init(Struct *spec, const char *fmt) {
    *spec = (Struct){
        .fmt=fmt,
        .ali=0,
    };
    int c = *fmt++;
    if (c == '=') {
        return spec;
    }
    spec->ali--;
    spec->fmt = fmt;
    while ( (c=*fmt++) ) {
        if ((c < 32) || (c > 127)) {
            errno = ERANGE;
            return NULL;
        }
        signed char ali = Struct_ALIGN[c];
        if (ali > spec->ali) {
            spec->ali = ali;
        }
    }
    return spec;
}

int 
unscans(Struct *restrict spec, const void *restrict src, argspec_t var) {
    size_t i = 0;
    const char *restrict fmt = spec->fmt;
    const size_t ali = spec->ali;
    for (int c=*fmt; c; c++) {
        switch (c) {
            case '?': {
                var.args[i].Y = ((_Bool *) src)[0];
            }
        }
    }
    '?' _Bool
    'c' char 
    'C' wchar_t
    'u' char16_t 
    'U' char32_t 
    'b' signed char 
    'h' signed short 
    'i' signed int 
    'l' signed long 
    'q' signed long long 
    'j' intmax_t 
    't' ptrdiff_t 
    'J' uintmax_t 
    'z' size_t
    'B' unsigned char 
    'H' unsigned short 
    'I' unsigned int 
    'L' unsigned long 
    'Q' unsigned long long 
    'p' intptr_t 
    'P' uintptr_t
    's' char * 
    'S' wchar_t *
    'F' short float
    'f' float
    'd' double 
    'D' long double 
    '%' uint32_t used as length of array
    '@' use packed alignment (must be first )
    '=' switch to native byteorder
    '<' switch to little byteorder
    '>' switch to netwrk byteorder
    
    ex: "?%%i" means 
        struct {
            bool;
            int[a][b];
        }
}

RE_EQ_BYTE          (uint8_t)
RE_EQ_CHAR          (uint16_t)
RE_EQ_WORD          (uint32_t)
RE_IN_BYTE_PAIR     (uint8_t[2])
RE_IN_CHAR_PAIR     (uint16_t[2])
RE_IN_WORD_PAIR     (uint32_t[2])
RE_IN_BYTE_RANGE    (uint8_t, uint8_t)
RE_IN_CHAR_RANGE    (uint16_t, uint16_t)
RE_IN_WORD_RANGE    (uint32_t, uint32_t)
RE_IN_BYTE_SET      (uint8_t[])
RE_IN_CHAR_SET      (uint16_t[])
RE_IN_WORD_SET      (uint32_t[])

s = {
    [0] = 32,         // SPACE
    [1] = 59,         // SEMICOLON
    [2] = {65, 90},   // A..Z
    [3] = {97, 122},  // a..z
}

_ = 30
a = 0
z = 4

i = (((a=0)+(z=4))>>1)==2
s[2]=={65, 90}
30 < {65, 90} ? (z>>=1)==2

i = (((a=0)+(z=2))>>1)==1
s[1]==59
30 < 59 ? 


os.system(f"clang {SRC} -o untest -I /sdcard/Python/unsys -lm")

set = {{'0', '0'}}

add '1' =>
set = {{'0', '1'}} (size±0)

add '3' =>
set = {{'0', '1'}, {'3', '3'}} (size++)

add '2' =>
set = {{'0', '3'}} (size--)
*/


/*
array_t *
array_APPEND(array_t *restrict a, const void *restrict e) {
    const size_t used = ++a->used;
    if (used >= a->size) {
        if (a-)
    }
}
struct INSERT_ARGS {
    struct {
        void    *addr;
        size_t  *used;
        size_t  *size;
    } seq;
    const void *item;
    size_t pos;
    size_t itemsize;
};

static inline int
INSERT(struct INSERT_ARGS *x) {
        Insert x->item (of size x-itemsize) in the simple array 
        represented as the bytearray referenced by x->seq.addr.
        The dynamically allocated array is capable of storing
        *x->seq.size elements, but only *x->seq.used slots are
        actually occupied. When *x->seq.used is one less than 
        *x->seq.size, insertion would result in the filling of 
        the array. This triggers an attempt to automatically
        resize the block of memory at x->seq.addr to twice its 
        current size. E.g. if used is 15 and size is 16, INSERT 
        will attempt to use realloc to resize x->seq.addr to a 
        block capable of storing 32 elements before performing
        the insertion.
        
        Elements may only be inserted between [0..*x->seq.used];
        if x->pos is greater than *x->seq.used, x->pos is set 
        to *x->seq.used. This adjustment occurs before checking
        whether or not the array should be resized.
    void *restrict dst = x->seq.addr;
    if (x->used == 0) {
        append: {
            (void) memcpy(dst, x->item, x->itemsize);
        }
    }
    else {
        size_t size_nbytes = x->itemsize**x->seq.size;
        size_t used_nbytes = x->itemsize**x->seq.used;
        size_t next_nbytes = x->itemsize+used_nbytes;
        if (next_nbytes > size_nbytes) {
            dst = realloc(dst, size_nbytes*=2);
            if (dst == NULL) {
                return errno;
            }
            *x->seq.size *= 2;
        }
        if (x->pos >= *x->seq.used) {
            src += next_nbytes;
            goto append;
        }
        const size_t mov = x->pos*x->itemsize;
        dst += mov;
        (void) memmove(dst, dst+x->itemsize, next_nbytes-mov);
        goto append;
    }
    *x->seq.used++;
    return errno;
    
}

*/

int main(void) {
    errno = 0;
    Dict *dict = Dict_new(10+6+6);
    dict->hash = uncasehash;
    dict->kcmp = strcasecmp;
    char vals[] = "0123456789ABCDEFabcdef";
    const char *keys[] = {
        "DIGIT ZERO",
        "DIGIT ONE",
        "DIGIT TWO",
        "DIGIT THREE",
        "DIGIT FOUR",
        "DIGIT FIVE",
        "DIGIT SIX",
        "DIGIT SEVEN",
        "DIGIT EIGHT",
        "DIGIT NINE",
        "LATIN CAPITAL LETTER A",
        "LATIN CAPITAL LETTER B",
        "LATIN CAPITAL LETTER C",
        "LATIN CAPITAL LETTER D",
        "LATIN CAPITAL LETTER E",
        "LATIN CAPITAL LETTER F",
        "LATIN SMALL LETTER A",
        "LATIN SMALL LETTER B",
        "LATIN SMALL LETTER C",
        "LATIN SMALL LETTER D",
        "LATIN SMALL LETTER E",
        "LATIN SMALL LETTER F",
        0
    };
    for (int i=0; keys[i]; i++) {
        Dict_put(dict, keys[i], vals+i);
    }

    Array *str = Array_new(C__WCHAR, 0);
    assert(Array_append(str, (wchar_t[]){'s'}));
    assert(Array_append(str, (wchar_t[]){'m'}));
    assert(Array_append(str, (wchar_t[]){'d'}));
    assert(Array_append(str, (wchar_t[]){' '}));

    assert(Array_setitem(str, 3, L"!"));


    #if 0 /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
    printf("[BEFORE] setitem(str, 7, L\"!\"):\n    ");
    if (Array_REPR(str, 0) > 0) {
        printf("\n");
    }
    #endif /* ……………………………………………………………………………………………………*/
    
    assert(    Array_setitem(str, 7, L"!"));
    
    #if 0 /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
    printf("[AFTER ] setitem(str, 7, L\"!\"):\n    ");
    if (Array_REPR(str, 0) > 0) {
        printf("\n");
    }
    #endif /* ……………………………………………………………………………………………………*/


    assert(Array_append(str, (wchar_t[]){0}));
    assert(Array_insert(str, 2, (wchar_t[]){'f'}));
    
    wchar_t excl = 123456789;
    
    for (int ind=0; ind < 9; ind++) {
        assert(Array_getitem(str, ind, &excl));
        (void) printf(     "getitem(str, %d, &excl) => %d\n", ind, excl);
    }

    #if 0 /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
    printf("[BEFORE] delitem(str, 7):\n    ");
    if (Array_REPR(str, 0) > 0) {
        printf("\n");
    }
    #endif /* ……………………………………………………………………………………………………*/
    
    assert(    Array_delitem(str, 7, &excl));
    
    #if 0
    printf("[AFTER ] delitem(str, 7):\n    ");
    if (Array_REPR(str, 0) > 0) {
        printf("\n");
    }
    #endif
    #if 0
    printf("str->used = %zu\n", (size_t) str->used);
    printf("str->size = %zu\n", (size_t) str->size);
    printf("str->data = %p\n", str->data.x);
    printf("Array_GET_ITEMSIZE(str) => %u\n", Array_GET_ITEMSIZE(str));
    #endif
    #if 0
    char chrs[] = {
        (char) ((wchar_t *) str->addr)[0],
        (char) ((wchar_t *) str->addr)[1],
        (char) ((wchar_t *) str->addr)[2],
        (char) ((wchar_t *) str->addr)[3],
        0,
    };
    printf("%s\n", chrs);
    #endif
    #if 0
    wchar_t chr[5];
    assert(Array_getitem(chr+0, str, 0));
    assert(Array_getitem(chr+1, str, 0));
    assert(Array_getitem(chr+2, str, 0));
    assert(Array_getitem(chr+3, str, 0));
    #endif

    
    int fd = open("untest.shm", O_CREAT|O_WRONLY|O_TRUNC|O_CLOEXEC);
    if (fd >= 0) {
        (void) posix_fallocate(fd, 0, sysconf(_SC_PAGE_SIZE));
        (void) write(fd, Array_GET_DATA(str), Array_GET_NBYTES(str));
        (void) close(fd);
    }
    else {
        perror("open?");
        exit(EXIT_FAILURE);
    }
    
    #if 0
    printf(
        "str->data.C[0] = %ld\n"
        "str->data.C[1] = %ld\n",
        (Array_getitem(&tmp[0].x, str, 0) == NULL ? 0L-1L : (long) *tmp[0].C),
        (Array_getitem(&tmp[1].x, str, 1) == NULL ? 0L-1L : (long) *tmp[1].C)
    );
    
    printf("str[0] => %ji\n", (intmax_t) chr[0]);
    printf("str[1] => %ji\n", (intmax_t) chr[1]);
    printf("str[2] => %ji\n", (intmax_t) chr[2]);
    printf("str[3] => %ji\n", (intmax_t) chr[3]);
    #endif
    
    Array_destroy(str);
    printf("the end\n");

#if 0
    printf("dict->size = %zu\n", dict->size);
    printf("dict->used = %u\n",  dict->used);
    printf("dict->nkey = %u\n", dict->nkey);
    for (hash_t slot=0; slot < dict->size; slot++) {
        DictItem *i = dict->map[slot];
        if (i->key != NULL) {
            printf(
                "dict->map[%u] = {\"%s\", '%c'}\n",
                slot,
                i->key,
                *((char *) i->val));
        }
    }
    const char *kee = "DiGiT sEvEn";
    printf(
        "dict.get(\"%s\") -> '%c'\n",
        kee,
        *((const char *) Dict_get(dict, kee)));
    FILE *src = fopen("/sdcard/Python/unsys/blocks.txt", "r");
    if (src == NULL) {
        perror("fopen"), exit(EXIT_FAILURE);
    }
    size_t len;
    char *line = NULL; // = "00000..0007f ascii           : Basic_Latin\n";
    if (getline(&line, &len, src) < 0) {
        perror("getline"), exit(EXIT_FAILURE);
    }
    struct UCD_block *bp = UCD_BLOCK;
    int sfr = sscanf(
        line,
        "%x..%x%16s",
        &bp->lo,
        &bp->hi,
        bp->id);
    printf("%05x..%05x %.16s\n", bp->lo, bp->hi, bp->id);
    free(line);
    fclose(src);
    printf("sfr=%i; the end\n", sfr);
#endif
}
